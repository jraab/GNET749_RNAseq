# An alternative with this sort of design is to use the liklihood ratio test
# Using the LRT version of this to identify any genes with changes
dds_lrt <- DESeq(dds, test = 'LRT', full = ~condition, reduced = ~1)
# p-values here mean is there a difference between a model that contains our 'condition' and one without that
# But we can extract specific logFoldChanges as before
# but p-values will always be the same ( difference between full model and reduced)
resultsNames(dds_lrt)
res_lrt_brg <- lfcShrink(dds_lrt, contrast = c('condition', 'Brg1', 'NS'), type = 'ashr' )
res_lrt_brm <- lfcShrink(dds_lrt, contrast = c('condition', 'Brm', 'NS'), type = 'ashr' )
# fold changes differ
plot(res_lrt_brg$log2FoldChange, res_lrt_brm$log2FoldChange)
# but pvalues are the same
table(res_lrt_brg$padj == res_lrt_brm$padj)
load('data/arid2_es.Rda')
dds
metadata(dds0
metadata(dds)
metadata(dds)
metadata(dds)$version
dds
es_dds <- dds
es_dds <- DESeq(es_dds)
design(es_dds)
# controlling for treatment, does genotype have an effect
res_genotype <- lfcShrink(dds, contrast = c('genotype', 'ARID2', 'WT'), type = 'ashr' )
es_dds <- DESeq(es_dds)
View(res_double)
# controlling for treatment, does genotype have an effect
res_genotype <- lfcShrink(es_dds, contrast = c('genotype', 'ARID2', 'WT'), type = 'ashr' )
summary(res_genotype)
res_genotype %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(padj) %>%
head(20)
df <- plotCounts(dds, gene = 'Mapk8ip2', intgroup = c('genotype', 'treat' ), returnData = T)
df %>%
ggplot(aes(x = treat, y = log2(count), color = genotype) ) +
geom_point(position = position_dodge(0.5))
design(es_dds)
# Since we have multiple genotype and treatments, and LRT test might be better
dds_treat <- DESeq(dds, test = 'LRT', full = ~ genotype + treat, reduced = ~genotype)
resultsNames(dds_treat)
res_treat <- lfcShrink(dds_treat, contrast= c('treat', 'EB', 'ES'), type = 'ashr' )
res_treat
res_genotype2 <- lfcShrink(dds_treat, contrast = c('genotype' , 'ARID2', 'WT'), type = 'ashr')
res_genotype2
summary(res_treat)
table(res_treat$padj == res_genotype2$padj)
res_treat %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(padj) %>%
head(20)
df <- plotCounts(dds, gene = 'Olfr1459', intgroup = c('genotype', 'treat' ), returnData = T)
df %>%
ggplot(aes(x = treat, y = log2(count), color = genotype) ) + geom_point(position = position_dodge(0.5))
# Is there an effect that differs by genotype
dds_interaction <- dds
design(dds_interaction) <- formula(~treat + genotype + treat:genotype)
dds_interaction <- DESeq(dds_interaction, test = 'LRT',
full = design(dds_interaction),
reduced = ~genotype + treat)
resultsNames(dds_interaction) # while it looks like you could extract other comparisons,
# all the p-values come from the LRT models we tested, so they will differ than if we perform the Wald tests above
res_interaction <- lfcShrink(dds_interaction, name = 'treatFGF48.genotypeWT', type = 'ashr' )
# all the p-values come from the LRT models we tested, so they will differ than if we perform the Wald tests above
res_interaction <- lfcShrink(dds_interaction, contrast = 'treatFGF48.genotypeWT', type = 'ashr' )
# all the p-values come from the LRT models we tested, so they will differ than if we perform the Wald tests above
res_interaction <- lfcShrink(dds_interaction, coef = 'treatFGF48.genotypeWT', type = 'ashr' )
summary(res_interaction)
res_interaction %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(padj) %>%head(20)
res_interaction
res_interaction %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(padj) %>%head(20)
plotCounts(dds_interaction, gene = 'Srp54b', intgroup = c('genotype', 'treat' ), returnData=T) %>%
ggplot(aes(x = genotype, y = count, color = treat ))  + geom_point() +
facet_wrap(~treat)
res_genotype_WT_vs_ARID2 <- results(dds_interaction, contrast = c('genotype', 'WT', 'ARID2'))
table(res_genotype_WT_vs_ARID2$padj < 0.1)
table(res_interaction$padj < 0.1)
table(res_genotype_WT_vs_ARID2$log2FoldChange > 5)
table(res_interaction$log2FoldChange > 5)
res_genotype_WT_vs_ARID2 %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(log2FoldChange) %>% head(20)
# These data are come from GEO - GSE102560 and the raw count matrix can be downloaded - I'll also put this on Sakai
# This is a bit more complicated as we have 5 different experimental conditions and multiple batches
# all from bioconductor
library(DESeq2)
library(sva) # needed to find surrogate variables (i.e. batches)
library(RUVseq)
library(tidyverse)
# Load our DESeqDataSet stored in GSE102560.Rda
load('data/GSE102560_dds.Rda')
#rename this
swi_dds <- dds
design(swi_dds)
colData(swi_dds)
# condition of interest should always be last (so batch first)
design(swi_dds_correct) <- formula(~batch + condition)
#Now use VST and PCA to look for batch effects
vsd <- varianceStabilizingTransformation(dds, blind = T)
plotPCA(vsd) # looks like there is not perfect grouping
# Let's replot and show replicate as shape
pp <- plotPCA(vsd, intgroup = c('condition', 'rep'), returnData = T)
pp
pp
pp %>%
ggplot(aes( x = PC1, y = PC2, color = condition, shape = rep)) +
geom_point(size = 3)
cdata <- colData(swi_dds_correct)
cdata <- cdata |> as.data.frame() |> mutate(rep = as.factor(rep),
condition = as.factor(condition) )
cdata
cdata <- colData(swi_dds_correct)
#Now its clear that there is a batch effect
# Lets compare results accounting for batch and ignoring batch
# DEseq with batch accounted for
swi_dds
cdata <- colData(swi_dds)
cdata <- cdata |> as.data.frame() |> mutate(rep = as.factor(rep),
condition = as.factor(condition) )
cdata
cdata |> as_tibble()
cdata <- cdata |> as.data.frame() |> mutate(rep = as.factor(rep),
condition = as.factor(condition) )
colData(swi_dds_correct)
colData(swi_dds)
design(swi_dds)
design(swi_dds) <- formula( ~ rep + condition )
colData(swi_dds)$rep <- as.factor(colData(swi_dds_correct)$rep)
colData(swi_dds)$rep <- as.factor(colData(swi_dds)$rep)
colData(swi_dds_correct)
colData(swi_dds)$rep <- as.factor(colData(swi_dds)$rep)
colData(swi_dds)
design(swi_dds) <- formula( ~ rep + condition )
design(swi_dds)
swi_dds <- DESeq(swi_dds)
# DESEq without batch accounted for
swi_dds_uncorrected <- swi_dds
design(swi_dds_uncorrect) <- formula(~ condition)
design(swi_dds_uncorrected) <- formula(~ condition)
design(swi_dds_uncorrected)
swi_dds <- DESeq(swi_dds_uncorrected)
resultsNames(swi_dds)
resultsNames(swi_dds_uncorrected)
design(swi_dds)
design(swi_dds) <- formula( ~ rep + condition )
design(swi_dds)
swi_dds <- DESeq(swi_dds)
resultsNames(swi_dds)
res_swi_correct <- results(swi_dds, contrast  = c('condition', 'Brg1', 'NS') )
res_swi_uncorrected  <- results(swi_dds_uncorrected, contrast = c('condition', 'Brg1', 'NS') )
#
# Let's plot number of signifcant genes as a bargraph
corrected_sig <- res_swi_correct %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05) |>
mutate(test = 'Corrected')
uncorrected_sig <- res_swi_uncorrected %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05 ) %>%
mutate(test = 'Uncorrected')
rbind(corrected_sig, uncorrected_sig ) %>%
group_by(test) %>%
summarise(total_sig = n() ) %>%
ggplot(aes(x = test, y = total_sig)) +
geom_col()
swi_dds
design(swi_dds)
swi_dds_uncorrected
design(swi_dds_uncorrected)
res_swi_correct <- results(swi_dds, contrast  = c('condition', 'Brg1', 'NS') )
res_swi_uncorrected  <- results(swi_dds_uncorrected, contrast = c('condition', 'Brg1', 'NS') )
#
# Let's plot number of signifcant genes as a bargraph
corrected_sig <- res_swi_correct %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05) |>
mutate(test = 'Corrected')
uncorrected_sig <- res_swi_uncorrected %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05 ) %>%
mutate(test = 'Uncorrected')
rbind(corrected_sig, uncorrected_sig ) %>%
group_by(test) %>%
summarise(total_sig = n() ) %>%
ggplot(aes(x = test, y = total_sig)) +
geom_col()
res_swi_correc
res_swi_correct
res_swi_uncorrected
swi_dds_uncorrected
design(swi_dds_uncorrected)
res_swi_uncorrected
summary(res_swi_uncorrected)
swi_dds <- DESeq(swi_dds_uncorrected)
res_swi_uncorrected  <- results(swi_dds_uncorrected, contrast = c('condition', 'Brg1', 'NS') )
uncorrected_sig <- res_swi_uncorrected %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05 ) %>%
mutate(test = 'Uncorrected')
rbind(corrected_sig, uncorrected_sig ) %>%
group_by(test) %>%
summarise(total_sig = n() ) %>%
ggplot(aes(x = test, y = total_sig)) +
geom_col()
# But that just accounts for the batch effect when DE testing, it does not alter underlying counts
# If we know the batch information, we can use the limma package to remove them from the data
# this is useful if you want to PCA or work on the transformed count data
vsd <- varianceStabilizingTransformation(swi_dds)
rbind(corrected_sig, uncorrected_sig ) %>%
group_by(test) %>%
summarise(total_sig = n() ) %>%
ggplot(aes(x = test, y = total_sig)) +
geom_col()
res_swi_uncorrected
# These data are come from GEO - GSE102560 and the raw count matrix can be downloaded - I'll also put this on Sakai
# This is a bit more complicated as we have 5 different experimental conditions and multiple batches
# all from bioconductor
library(DESeq2)
library(limma) #needed for the removeBatchEffect function
library(sva) # needed to find surrogate variables (i.e. batches)
library(RUVseq)
library(tidyverse)
# Load our DESeqDataSet stored in GSE102560.Rda
load('data/GSE102560_dds.Rda')
#rename this
swi_dds <- dds
design(swi_dds)
# make a second dds to correct
swi_dds_correct <- swi_dds
# condition of interest should always be last (so batch first)
design(swi_dds_correct) <- formula(~batch + condition)
#rename this
swi_dds <- dds
design(swi_dds)
# make a second dds to correct
swi_dds_correct <- swi_dds
# condition of interest should always be last (so batch first)
design(swi_dds_correct) <- formula(~batch + condition)
swi_dds
# condition of interest should always be last (so batch first)
design(swi_dds_correct) <- formula(~rep + condition)
#Now use VST and PCA to look for batch effects
vsd <- varianceStabilizingTransformation(dds, blind = T)
plotPCA(vsd) # looks like there is not perfect grouping
# Let's replot and show replicate as shape
pp <- plotPCA(vsd, intgroup = c('condition', 'rep'), returnData = T)
pp
pp %>%
ggplot(aes( x = PC1, y = PC2, color = condition, shape = rep)) +
geom_point(size = 3)
#Now its clear that there is a batch effect
# Lets compare results accounting for batch and ignoring batch
# DEseq with batch accounted for
swi_dds
cdata <- colData(swi_dds)
cdata <- cdata |> as.data.frame() |> mutate(rep = as.factor(rep),
condition = as.factor(condition) )
colData(swi_dds)$rep <- as.factor(colData(swi_dds)$rep)
colData(swi_dds)
design(swi_dds) <- formula( ~ rep + condition )
design(swi_dds)
swi_dds <- DESeq(swi_dds)
# DESEq without batch accounted for
swi_dds_uncorrected <- swi_dds
design(swi_dds_uncorrected) <- formula(~ condition)
design(swi_dds_uncorrected)
swi_dds <- DESeq(swi_dds_uncorrected)
resultsNames(swi_dds)
resultsNames(swi_dds_uncorrected)
res_swi_correct <- results(swi_dds, contrast  = c('condition', 'Brg1', 'NS') )
res_swi_uncorrected  <- results(swi_dds_uncorrected, contrast = c('condition', 'Brg1', 'NS') )
#
# Let's plot number of signifcant genes as a bargraph
corrected_sig <- res_swi_correct %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05) |>
mutate(test = 'Corrected')
uncorrected_sig <- res_swi_uncorrected %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05 ) %>%
mutate(test = 'Uncorrected')
rbind(corrected_sig, uncorrected_sig ) %>%
group_by(test) %>%
summarise(total_sig = n() ) %>%
ggplot(aes(x = test, y = total_sig)) +
geom_col()
# But that just accounts for the batch effect when DE testing, it does not alter underlying counts
# If we know the batch information, we can use the limma package to remove them from the data
# this is useful if you want to PCA or work on the transformed count data
vsd <- varianceStabilizingTransformation(swi_dds)
vsd_batch_removed <- vsd
vsd$rep
# This step alters the variance stabilized data to remove the batch effect using limma
assay(vsd_batch_removed) <- limma::removeBatchEffect(assay(vsd_batch_removed), batch = vsd$rep)
# Now we can replot as before
pbatch <- plotPCA(vsd_batch_removed, c('condition', 'rep'), returnData = T)
pbatch |>
ggplot(aes( x = PC1, y = PC2, color = condition, shape = rep)) +
geom_point(size = 3)
#  Here, we'll try SVA - surrogate variable analysis.
# we need to give it a full model with our variables of interest, here just condition
cdata <- colData(swi_dds)
cdata
full <- model.matrix(~condition, data = cdata)
full
# and a reduced model with any remaining variables, here just the intercept (1)
reduced <- model.matrix(~1, data = cdata)
reduced
# Then we can get the normalized count data from dds
dat <- counts(swi_dds, normalized = T)
# And remove any very lowly expressed genes since the won't e informative
idx <- rowMeans(dat) > 1
idx
table(idx)
svobj <- sva::svaseq(dat, full, reduced) # we can ad the number of surrogate variables here as n.sv = , but I"m leaving it to sva to estimate
dat
svobj <- sva::svaseq(dat, full, reduced) # we can ad the number of surrogate variables here as n.sv = , but I"m leaving it to sva to estimate
# Then we can get the normalized count data from dds
dat <- counts(swi_dds, normalized = T)
# And remove any very lowly expressed genes since the won't e informative
idx <- rowMeans(dat) > 1
idx
table(idx)
dat <- dat[idx,]
svobj <- sva::svaseq(dat, full, reduced) # we can ad the number of surrogate variables here as n.sv = , but I"m leaving it to sva to estimate
svobj # this gave 2 surrogate variable
# Now we can use these variables in our DESeq analysis as covariates in our model
dds_sva <- swi_dds
dds_sva
dds_sva$V1 <- svobj$sv[,1] # This adds the surrogate variables to our colData
dds_sva$V2 <- svobj$sv[,2]
dds_sva
design(dds_sva) <- ~V1 +V2 + condition # Including them here asks DESEq to account for those variables
dds_sva <- DESeq(dds_sva)
sva_res <- results(dds_sva, contrast = c('condition', 'Brg1', 'NS') )
summary(sva_res)
summary(res_swi_correct)
summary(res_swi_uncorrected)
# we can also try to fix the pca using this new component
vsd_sva <- varianceStabilizingTransformation(dds_sva, blind = T)
assay(vsd_sva) <- limma::removeBatchEffect(assay(vsd_sva), covariates = svobj$sv)
plotPCA(vsd, intgroup = c('condition') )
plotPCA(vsd_batch_removed, intgroup = 'condition') #using known batch
plotPCA(vsd_sva, intgroup = 'condition')   # SVA batches
# Does this method actually work - well lets permute the labels on our design matrix
cdata
cdata_permute <- cdata
cdata_permute$condition <- sample(cdata_permute$condition, replace = F) # shuffle the labels
cdata_permute # now our labelled condition no longer matches our real condition
full_wrong <- model.matrix(~condition, data =cdata_permute)
reduced_wrong <- model.matrix(~1, data = cdata_permute)
full_wrong
reduced_wrong
sva_wrong <- sva::svaseq(dat, full_wrong, reduced_wrong)
# This came up with 3 surrogate variables
dds_wrong <- DESeqDataSetFromMatrix(counts(swi_dds), colData = cdata_permute, design = ~ condition)
dds_wrong$V1 <- sva_wrong$sv[,1]
dds_wrong$V2 <- sva_wrong$sv[,2]
dds_wrong$V3 <- sva_wrong$sv[,3]
design(dds_wrong) <- ~V1 + V2 + V3 + condition
design(dds_wrong)
dds_wrong <- DESeq(dds_wrong)
res_wrong <- results(dds_wrong, contrast = c('condition', 'Brg1', 'NS') )
summary(res_wrong)
# How about clustering - does adding inferred batches cause inappropriate clustering
vsd_wrong <- varianceStabilizingTransformation(dds_wrong, blind = T)
assay(vsd_wrong) <- limma::removeBatchEffect(assay(vsd_wrong), covariates = sva_wrong$sv)
plotPCA(vsd_wrong, intgroup = c('condition', 'rep'), returnData = T)  %>%
separate(name, into = c('type', 'rep'), sep ='_')  %>%
ggplot(aes(x = PC1, y = PC2, color = type, shape = rep)) +
geom_point(size = 3)
# Advanced Experimental Designs
# How to handle more complex experimental designs
library(DESeq2)
library(limma)
library(sva)
library(tximport)
library(tidyverse)
library(ComplexHeatmap)
################################################################################
# In this example  we are testing how to look at mulitple gruops
# we have  knockdown experiments of two different proteins, both proteins together, or a control
load('data/GSE102560_dds.Rda')
# Here is our data converted to a DESeq Dataset
dds$condition
dds$condition <- relevel(dds$condition, 'NS')
# Here is our data converted to a DESeq Dataset
dds$condition
# We can perform a normal Wald test using DESEq as we usually would
# wald is default
dds <- DESeq(dds)
# Now you can see the mulitple comparisons available
resultsNames(dds)
# Extracting different comparisons to NS is easy using the contrast argument
res_brg <- results(dds, contrast = c('condition', 'Brg1', 'NS') ) # contrast takes the form of factor, numerator, denominator
res_brm <- results(dds, contrast = c('condition', 'Brm', 'NS') )
res_double <- results(dds, contrast = c('condition', 'Double', 'NS') )
# apeglm requires use of coef, so use resultsNames(dds) to get the right coef number
res_brg <- lfcShrink(dds, coef = 2, res= res_brg, type = 'apeglm')
res_brm <- lfcShrink(dds, coef = 3, res= res_brm, type = 'apeglm')
res_double <- lfcShrink(dds, coef = 4, res= res_double, type = 'apeglm')
# saving these data for enrichment analysis
write_csv(as.data.frame(res_brg) |> rownames_to_column() , file = 'data/results_brg1.csv')
write_csv(as.data.frame(res_brm) %>% rownames_to_column(), file = 'data/results_brm.csv')
write_csv(as.data.frame(res_double) %>% rownames_to_column(), file = 'data/results_double.csv')
#what if we wanted to compare the two single mutants -
res_brg_vs_brm <- lfcShrink(dds, contrast = c('condition', 'Brg1', 'Brm'), type = 'ashr' )
# what if we don't want to compare things pair-wise, this is where its a bit more complicated
# lets say we want to know if there is a difference between one group and the average of the others.
# We need to rerun our DESeq analysis with one additional argument
# betaPrior = T reverts DESeq to how a prior version worked and gives us access to
# the average value for multiple groups. An alternative approach is to change the design matrix
# to ~ 0 + condition (forcing the intercept to be 0). See the DESeq vignette for more info
dds_beta <- DESeq(dds, betaPrior = T)
dds_beta
# Now we can see that there is a coefficient for each condition rather than for the comparison
resultsNames(dds_beta)
# We can then compare the numerator of interest (Brg1) to the average of the remaining conditions.
# listValues() lets you specify what value you will multiply each coefficent by
x <- results(dds_beta, contrast = list('conditionBrg1', c('conditionNS', 'conditionBrm', 'conditionDouble')),
listValues = c(1, -1/3 ) )
x
x |> as.data.frame() |> rownames_to_column() |> arrange(padj)
plotCounts(dds_beta, gene = 'SMARCA4', intgroup = 'condition')
plotCounts(dds_beta, gene = 'PHYHIPL', intgroup = 'condition')
plotCounts(dds_beta, gene = 'BMP6', intgroup = 'condition')
# Heatmap
top_50 <- as.data.frame(x) %>% rownames_to_column() %>% arrange(padj) %>% head(50)
counts <- assay(dds_beta)[rownames(dds_beta) %in% top_50$rowname, ]
counts <- t(scale(t(counts), center = T, scale =T))
Heatmap(counts)
# An alternative with this sort of design is to use the liklihood ratio test
# Using the LRT version of this to identify any genes with changes
dds_lrt <- DESeq(dds, test = 'LRT', full = ~condition, reduced = ~1)
# p-values here mean is there a difference between a model that contains our 'condition' and one without that
# But we can extract specific logFoldChanges as before
# but p-values will always be the same ( difference between full model and reduced)
resultsNames(dds_lrt)
res_lrt_brg <- lfcShrink(dds_lrt, contrast = c('condition', 'Brg1', 'NS'), type = 'ashr' )
res_lrt_brm <- lfcShrink(dds_lrt, contrast = c('condition', 'Brm', 'NS'), type = 'ashr' )
# fold changes differ
plot(res_lrt_brg$log2FoldChange, res_lrt_brm$log2FoldChange)
# but pvalues are the same
table(res_lrt_brg$padj == res_lrt_brm$padj)
load('data/arid2_es.Rda')
es_dds <- dds
es_dds <- DESeq(es_dds)
design(es_dds)
# controlling for treatment, does genotype have an effect
res_genotype <- lfcShrink(es_dds, contrast = c('genotype', 'ARID2', 'WT'), type = 'ashr' )
summary(res_genotype)
res_genotype %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(padj) %>%
head(20)
df <- plotCounts(dds, gene = 'Mapk8ip2', intgroup = c('genotype', 'treat' ), returnData = T)
df %>%
ggplot(aes(x = treat, y = log2(count), color = genotype) ) +
geom_point(position = position_dodge(0.5))
# Since we have multiple genotype and treatments, and LRT test might be better
dds_treat <- DESeq(dds, test = 'LRT', full = ~ genotype + treat, reduced = ~genotype)
resultsNames(dds_treat)
res_treat <- lfcShrink(dds_treat, contrast= c('treat', 'EB', 'ES'), type = 'ashr' )
res_treat
summary(res_treat)
res_genotype2 <- lfcShrink(dds_treat, contrast = c('genotype' , 'ARID2', 'WT'), type = 'ashr')
res_genotype2
summary(res_treat)
table(res_treat$padj == res_genotype2$padj)
res_treat %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(padj) %>%
head(20)
df <- plotCounts(dds, gene = 'Olfr1459', intgroup = c('genotype', 'treat' ), returnData = T)
df %>%
ggplot(aes(x = treat, y = log2(count), color = genotype) ) + geom_point(position = position_dodge(0.5))
# Is there an effect that differs by genotype
dds_interaction <- dds
design(dds_interaction) <- formula(~treat + genotype + treat:genotype)
dds_interaction <- DESeq(dds_interaction, test = 'LRT',
full = design(dds_interaction),
reduced = ~genotype + treat)
resultsNames(dds_interaction) # while it looks like you could extract other comparisons,
# all the p-values come from the LRT models we tested, so they will differ than if we perform the Wald tests above
res_interaction <- lfcShrink(dds_interaction, coef = 'treatFGF48.genotypeWT', type = 'ashr' )
summary(res_interaction)
res_interaction %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(padj) %>%head(20)
plotCounts(dds_interaction, gene = 'Podxl', intgroup = c('genotype', 'treat' ), returnData=T) %>%
ggplot(aes(x = genotype, y = count, color = treat ))  + geom_point() +
facet_wrap(~treat)
