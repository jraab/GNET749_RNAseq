geom_vline(aes(xintercept = 0), linetype = 'dashed', color ='grey30' ) +
ggrepel::geom_text_repel(aes(label = symbol), data= top_10, color = 'grey20') #new aesthetic, remember we can supply different dataframe here (top_10)
# Now we can look at our results - we might specifically want to pick out our most significant genes and take a look
sdf %>%
filter(!is.na(padj) ) %>%
arrange(padj) %>%
head(30)
#Need to change the names in the original rownames of the des
rn <- rownames(des)
rn
rn_df <- data.frame(ensgene = rn)
rn_df
anno_df
rn_df <- left_join(rn_df, anno_df, by = 'ensgene', multiple='first' )
rn_df |> head()
# multiple= 'first' , there are a few ens genes with more than one annotatation - this takes the first so that rownames match
rownames(des) <- rn_df$symbol
top_10
# Plot some of these using plotCounts
DEseq2::plotCounts(des, gene = 'DDX3Y', intgroup = 'Group', norm = T) # DDX3Y
# Plot some of these using plotCounts
DESeq2::plotCounts(des, gene = 'DDX3Y', intgroup = 'Group', norm = T) # DDX3Y
plotCounts(des, gene = 'POP1', intgroup = 'Group', norm = T)
plotCounts(des, gene = 'DDX3X', intgroup  = 'Group', norm = T)
plotCounts(des, gene = 'DDX3X', intgroup  = 'Group', norm = T, returnData = T)
plotCounts(des, gene = 'DDX3X', intgroup  = 'Group', norm = T, returnData = T) |>
ggplot(aes(x = Group, y = count)) + geom_boxplot()
# Threshold by an arbitrary logfoldchange cutoff
res_filt <- results(des, lfcThreshold = abs(1) )
summary(res_filt)
# Heatmap of significantly changed genes
norm_counts <- counts(des, norm = T)
# get a list of genes
genes <- sdf %>% filter(padj < 0.1) |>  filter(symbol != '') %>% pull(symbol) # pull is a new verb I just learned! it selects one column and returns a vector
genes
# keep just tne rows for those genes ( could use filters here as well, but b/c gene names are the rownames and not a column in the dataframe, the following is easier)
dim(norm_counts)
[rownames(norm_counts) %in% genes
rownames(norm_counts) %in% genes
table(rownames(norm_counts) %in% genes)
norm_counts <- norm_counts[rownames(norm_counts) %in% genes, ]
dim(norm_counts)
# I Like ComplexHeatmap for making heatmaps, although there are other packages (pheatmap, heatmap.2)
design <- colData(des)
design
column_ha <- HeatmapAnnotation(group = design$Group,
col = list(group =  c("A" = 'Grey10', 'B' = 'Steelblue')) ) # I get the syntax for colors wrong here all the timek
norm_counts
Heatmap(norm_counts, top_annotation = column_ha)
# That heatmap basically jut shows which genes are highly exprssed (not scaled by row)
vsd <- varianceStabilizingTransformation(des)
vsd <- vsd[rownames(vsd) %in%  genes]
Heatmap(as.matrix(assay(vsd)) , top_annotation = column_ha)
# Scale heatmap by row - this is usually what you want
scaled_hm <- t(scale(t(norm_counts), center = T, scale = T) )  # lets z-score our data by row
scaled_hm <- na.omit(scaled_hm)
scaled_vsd <- t(scale(t(assay(vsd)), center = T, scale = T) )
scaled_vsd <- na.omit(scaled_vsd)
# Lots happening above, key function is scale
column_ha <- HeatmapAnnotation(group = design$Group,
col = list(group =  c("A" = 'Grey10', 'B' = 'Steelblue')) )
Heatmap(scaled_hm, top_annotation = column_ha)
column_ha <- HeatmapAnnotation(group = design$Group,
col = list(group =  c("A" = 'Grey10', 'B' = 'Steelblue')) )
Heatmap(scaled_vsd, top_annotation = column_ha)
library(RUVseq)
# Load our DESeqDataSet stored in GSE10
load('data/GSE102560_dds.Rda')
#rename this
swi_dds <- dds
design(swi_dds)
# make a second dds to correct
swi_dds_correct <- swi_dds)
# condition of interest should always be last (so batch first)
design(swi_dds_correct) <- formula(~batch + condition)
# make a second dds to correct
swi_dds_correct <- swi_dds
# condition of interest should always be last (so batch first)
design(swi_dds_correct) <- formula(~batch + condition)
#Now its clear that there is a batch effect
# Lets compare results accounting for batch and ignoring batch
# DEseq with batch accounted for
swi_dds_correct <- DESeq(swi_dds_correct)
# DESEq without batch accounted for
swi_dds <- DESeq(swi_dds)
res_swi_uncorrected  <- results(swi_dds_correct, contrast = c('condition', 'Brg1', 'NS') )
#
# Let's plot number of signifcant genes as a bargraph
nobatch_sig <- res_swi_ccorrect %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05) %>%
mutate(test = 'Corrected')
uncorrected_sig <- res_swi_uncorrected %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05 ) %>%
mutate(test = 'Uncorrected')
rbind(correct_sig, uncorrected_sig ) %>%
group_by(test) %>%
summarise(total_sig = n() ) %>%
ggplot(aes(x = test, y = total_sig)) +
geom_col()
#
# Let's plot number of signifcant genes as a bargraph
corrected_sig <- res_swi_ccorrect %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05) %>%
mutate(test = 'Corrected')
#
# Let's plot number of signifcant genes as a bargraph
corrected_sig <- res_swi_correct %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05) %>%
mutate(test = 'Corrected')
rbind(corrected_sig, uncorrected_sig ) %>%
group_by(test) %>%
summarise(total_sig = n() ) %>%
ggplot(aes(x = test, y = total_sig)) +
geom_col()
#
# Let's plot number of signifcant genes as a bargraph
corrected_sig <- res_swi_correct %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05) %>%
mutate(test = 'Corrected')
res_swi_correct <- results(swi_dds_correct, contrast  = c('condition', 'Brg1', 'NS') )
#
# Let's plot number of signifcant genes as a bargraph
corrected_sig <- res_swi_correct %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05) %>%
mutate(test = 'Corrected')
rbind(corrected_sig, uncorrected_sig ) %>%
group_by(test) %>%
summarise(total_sig = n() ) %>%
ggplot(aes(x = test, y = total_sig)) +
geom_col()
res_swi_uncorrected  <- results(swi_dds, contrast = c('condition', 'Brg1', 'NS') )
#
# Let's plot number of signifcant genes as a bargraph
corrected_sig <- res_swi_correct %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05) %>%
mutate(test = 'Corrected')
uncorrected_sig <- res_swi_uncorrected %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05 ) %>%
mutate(test = 'Uncorrected')
rbind(corrected_sig, uncorrected_sig ) %>%
group_by(test) %>%
summarise(total_sig = n() ) %>%
ggplot(aes(x = test, y = total_sig)) +
geom_col()
swi_dds
design(swi_dds)
design(swi_dds_correct)
#Now its clear that there is a batch effect
# Lets compare results accounting for batch and ignoring batch
# DEseq with batch accounted for
design(swi_dds_correct) <- formula('~rep + condition')
#Now its clear that there is a batch effect
# Lets compare results accounting for batch and ignoring batch
# DEseq with batch accounted for
design(swi_dds_correct) <- formula(~rep + condition)
colData(swi_dds_correct)
cdata <- colData(swi_dds_correct)
cdata <- cdata |> mutate(rep = as.factor(rep) )
design(swi_dds_correct) <- formula(~rep + condition)
design(swi_dds_correct) <- formula(~rep + condition)
cdata <- cdata |> mutate(rep = as.factor(rep) )
cdata <- cdata |> as.data.frame() |> mutate(rep = as.factor(rep) )
colData(swi_dds_correct) <- cdata
colData(swi_dds_correct)
design(swi_dds_correct) <- formula(~as.factor(rep) + condition)
cdata
swi_dds_correct <- DESeqDataSet(swi_dds_correct, design = as.factor(rep) + condition)
swi_dds_correct
design(swi_dds_correct) <- formula(~as.factor(rep) + condition)
design(swi_dds_correct) <- formula(~as.factor(rep) + as.factor(condition))
cdata <- cdata |> as.data.frame() |> mutate(rep = as.factor(rep),
condition = as.factor(condition) )
cdata
colData(swi_dds_correct) <- cdata
swi_dds_correct <- DESeqDataSet(swi_dds_correct, design = as.factor(rep) + condition)
design(swi_dds_correct) <- formula(~as.factor(rep) + as.factor(condition))
colData(swi_dds_correct)
colData(swi_dds_correct)$rep <- as.factor(colData(swi_dds_correct)$rep)
colData(swi_dds_correct)
design(swi_dds_correct) <- formula(rep + condition)
design(swi_dds_correct)
design(swi_dds_correct) <- formula(rep + condition)
design(swi_dds_correct) <- rep + condition
design(swi_dds_correct) <- formula( ~ rep + condition )
design(swi_dds_correct)
swi_dds_correct <- DESeq(swi_dds_correct)
# DESEq without batch accounted for
swi_dds <- DESeq(swi_dds)
res_swi_correct <- results(swi_dds_correct, contrast  = c('condition', 'Brg1', 'NS') )
res_swi_uncorrected  <- results(swi_dds, contrast = c('condition', 'Brg1', 'NS') )
#
# Let's plot number of signifcant genes as a bargraph
corrected_sig <- res_swi_correct %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05) %>%
mutate(test = 'Corrected')
uncorrected_sig <- res_swi_uncorrected %>%
as.data.frame() %>%
rownames_to_column() %>%
filter(padj < 0.05 ) %>%
mutate(test = 'Uncorrected')
rbind(corrected_sig, uncorrected_sig ) %>%
group_by(test) %>%
summarise(total_sig = n() ) %>%
ggplot(aes(x = test, y = total_sig)) +
geom_col()
vsd_batch_removed <- vsd
vsd$rep
# This step alters the variance stabilized data to remove the batch effect using limma
assay(vsd_batch_removed) <- limma::removeBatchEffect(assay(vsd_batch_removed), batch = vsd$rep)
# Now we can replot as before
pbatch <- plotPCA(vsd_batch_removed, c('condition', 'rep'), returnData = T)
pbatch |>
ggplot(aes( x = PC1, y = PC2, color = condition, shape = rep)) +
geom_point(size = 3)
vsd_batch_removed <- vsd
# But that just accounts for the batch effect when DE testing, it does not alter underlying counts
# If we know the batch information, we can use the limma package to remove them from the data
# this is useful if you want to PCA or work on the transformed count data
vsd <- varianceStabilizingTransformation(swi_dds)
vsd_batch_removed <- vsd
vsd$rep
# This step alters the variance stabilized data to remove the batch effect using limma
assay(vsd_batch_removed) <- limma::removeBatchEffect(assay(vsd_batch_removed), batch = vsd$rep)
BiocManager::install(c('limma', 'sva', RUVseq))
BiocManager::install(c('limma', 'sva', 'RUVseq'))
BiocManager::install(c('limma', 'sva', 'RUVSeq'))
# This step alters the variance stabilized data to remove the batch effect using limma
assay(vsd_batch_removed) <- limma::removeBatchEffect(assay(vsd_batch_removed), batch = vsd$rep)
# Now we can replot as before
pbatch <- plotPCA(vsd_batch_removed, c('condition', 'rep'), returnData = T)
pbatch |>
ggplot(aes( x = PC1, y = PC2, color = condition, shape = rep)) +
geom_point(size = 3)
plotPCA(vsd_batch_removed, c('condition', 'rep') )
plotPCA(vsd_batch_removed, 'condition' )
#  Here, we'll try SVA - surrogate variable analysis.
# we need to give it a full model with our variables of interest, here just condition
cdata <- colData(swi_dds)
full <- model.matrix(~condition, data = cdata)
full
# and a reduced model with any remaining variables, here just the intercept (1)
reduced <- model.matrix(~1, data = design)
reduced
# and a reduced model with any remaining variables, here just the intercept (1)
reduced <- model.matrix(~1, data = cdata)
reduced
# Then we can get the normalized count data from dds
dat <- counts(dds, normalized = T)
# And remove any very lowly expressed genes since the won't e informative
idx <- rowMeans(dat) > 1
table(idx)
# Then we can get the normalized count data from dds
dat <- counts(swi_dds, normalized = T)
# And remove any very lowly expressed genes since the won't e informative
idx <- rowMeans(dat) > 1
table(idx)
dat <- dat[idx,]
svobj <- svaseq(dat, full, reduced) # we can ad the number of surrogate variables here as n.sv = , but I"m leaving it to sva to estimate
svobj <- sva::svaseq(dat, full, reduced) # we can ad the number of surrogate variables here as n.sv = , but I"m leaving it to sva to estimate
svobj # this gave 2 surrogate variable
# Now we can use these variables in our DESeq analysis as covariates in our model
dds_sva <- dds
dds_sva
dds_sva$V1 <- svobj$sv[,1] # This adds the surrogate variables to our colData
dds_sva$V2 <- svobj$sv[,2]
# Now we can use these variables in our DESeq analysis as covariates in our model
dds_sva <- swi_dds
dds_sva
dds_sva$V1 <- svobj$sv[,1] # This adds the surrogate variables to our colData
dds_sva$V2 <- svobj$sv[,2]
dds_sva
design(dds_sva) <- ~V1 +V2 + condition # Including them here asks DESEq to account for those variables
dds_sva <- DESeq(dds_sva)
sva_res <- results(dds_sva, contrast = c('condition', 'Brg1', 'NS') )
summary(sva_res)
summary(res_swi_correct)
summary(res_swi_uncorrected)
# we can also try to fix the pca using this new component
vsd_sva <- varianceStabilizingTransformation(dds_sva, blind = T)
assay(vsd_sva) <- limma::removeBatchEffect(assay(vsd_sva), covariates = svobj$sv)
plotPCA(vsd, intgroup = c('condition') )
plotPCA(vsd_batch_removed, intgroup = 'condition') #using known batch
plotPCA(vsd_sva, intgroup = 'condition')   # SVA batches
# Does this method actually work - well lets permute the labels on our design matrix
design
# Does this method actually work - well lets permute the labels on our design matrix
cdata
# Does this method actually work - well lets permute the labels on our design matrix
cdata
cdata_permute <- cdata
cdata_permute$condition <- sample(data_permute$condition, replace = F) # shuffle the labels
cdata_permute$condition <- sample(cdata_permute$condition, replace = F) # shuffle the labels
cdata_permute # now our labelled condition no longer matches our real condition
full_wrong <- model.matrix(~condition, data =cdata_permute)
reduced_wrong <- model.matrix(~1, data = cdata_permute)
full_wrong
reduced_wrong
# This came up with 3 surrogate variables
dds_wrong <- DESeqDataSetFromMatrix(mat, colData = cdata_permute, design = ~ condition)
mat
# This came up with 3 surrogate variables
dds_wrong <- DESeqDataSetFromMatrix(counts(swi_dds), colData = cdata_permute, design = ~ condition)
dds_wrong$V1 <- sva_wrong$sv[,1]
sva_wrong <- svaseq(dat, full_wrong, reduced_wrong)
library(sva) # needed to find surrogate variables (i.e. batches)
sva::sva()
sva_wrong <- sva::svaseq(dat, full_wrong, reduced_wrong)
# This came up with 3 surrogate variables
dds_wrong <- DESeqDataSetFromMatrix(counts(swi_dds), colData = cdata_permute, design = ~ condition)
dds_wrong$V1 <- sva_wrong$sv[,1]
dds_wrong$V2 <- sva_wrong$sv[,2]
dds_wrong$V3 <- sva_wrong$sv[,3]
design(dds_wrong) <- ~V1 + V2 + V3 + condition
design(dds_wrong)
dds_wrong <- DESeq(dds_wrong)
res_wrong <- results(dds_wrong, contrast = c('condition', 'Brg1', 'NS') )
summary(res_wrong)
# How about clustering - does adding inferred batches cause inappropriate clustering
vsd_wrong <- varianceStabilizingTransformation(dds_wrong, blind = T)
assay(vsd_wrong) <- limma::removeBatchEffect(assay(vsd_wrong), covariates = sva_wrong$sv)
plotPCA(vsd_wrong, intgroup = c('condition', 'rep'), returnData = T)  %>%
separate(name, into = c('type', 'rep'), sep ='_')  %>%
ggplot(aes(x = PC1, y = PC2, color = type, shape = rep)) +
geom_point(size = 3)
################################################################################
# In this example  we are testing how to look at mulitple gruops
# we have  knockdown experiments of two different proteins, both proteins together, or a control
load('data/GSE102560_dds.Rda')
# Here is our data converted to a DESeq Dataset
dds <- DESeqDataSetFromMatrix(mat, colData = design, design = ~ condition)
dds$condition <- relevel(dds$condition, 'NS')
# We can perform a normal Wald test using DESEq as we usually would
# wald is default
dds <- DESeq(dds)
# Now you can see the mulitple comparisons available
resultsNames(dds)
# Extracting different comparisons to NS is easy using the contrast argument
res_brg <- results(dds, contrast = c('condition', 'Brg1', 'NS') ) # contrast takes the form of factor, numerator, denominator
res_brm <- results(dds, contrast = c('condition', 'Brm', 'NS') )
res_double <- results(dds, contrast = c('condition', 'Double', 'NS') )
?lfcShrink
geom_point(size =
resultsNames(dds)
res_brg <- lfcShrink(dds, coef = 2, res= res_brg, type = 'apeglm')
res_brm <- lfcShrink(dds, coef = 3, res= res_brm, type = 'apeglm')
res_double <- lfcShrink(dds, coef = 4, res= res_double, type = 'apeglm')
plotMA(res_double)
plotMA(res_brg)
plotMA(res_brm)
# saving these data for enrichment analysis
write_csv(as.data.frame(res_brg) %>% rownames_to_column() , file = 'data/results_brg1.csv')
write_csv(as.data.frame(res_brm) %>% rownames_to_column(), file = 'data/results_brm.csv')
write_csv(as.data.frame(res_double) %>% rownames_to_column(), file = 'data/results_double.csv')
resultsNames
resultsNames(dds)
model.matrix(dds)
model.matrix(dds$condition)
dds$condition
#what if we wanted to compare the two single mutants
res_brg_vs_brm <- lfcShrink(dds, contrast = c('condition', 'Brg1', 'Brm'), method = 'ashr' )
#what if we wanted to compare the two single mutants
res_brg_vs_brm <- lfcShrink(dds, contrast = c('condition', 'Brg1', 'Brm'), type = 'ashr' )
plotMA(res_brg_vs_brm)
# what if we don't want to compare things pair-wise, this is where its a bit more complicated
# lets say we want to know if there is a difference between one group and the average of the others.
# We need to rerun our DESeq analysis with one additional argument
# betaPrior = T reverts DESeq to how a prior version worked and gives us access to
# the average value for multiple groups. An alternative approach is to change the design matrix
# to ~ 0 + condition (forcing the intercept to be 0). See the DESeq vignette for more info
dds_beta <- DESeq(dds, betaPrior = T)
dds_beta
# Now we can see that there is a coefficient for each condition rather than for the comparison
resultsNames(dds_beta)
# We can then compare the numerator of interest (Brg1) to the average of the remaining conditions.
# listValues() lets you specify what value you will multiply each coefficent by
x <- results(dds_beta, contrast = list('conditionBrg1', c('conditionNS', 'conditionBrm', 'conditionDouble')),
listValues = c(1, -1/3) )
x
# We can then compare the numerator of interest (Brg1) to the average of the remaining conditions.
# listValues() lets you specify what value you will multiply each coefficent by
x <- results(dds_beta, contrast = list('conditionBrg1', c('conditionNS', 'conditionBrm', 'conditionDouble')),
listValues = c(1, -1/3, -1/3, -1/3) )
x
# We can then compare the numerator of interest (Brg1) to the average of the remaining conditions.
# listValues() lets you specify what value you will multiply each coefficent by
x <- results(dds_beta, contrast = list('conditionBrg1', c('conditionNS', 'conditionBrm', 'conditionDouble')),
listValues = c(1, -1/3 ) )
x
x |> as.data.frame() |> arrange(padj)
x |> as.data.frame() |> arrange(padj) |> head()
plotCounts(dds_beta, gene = 'SMARCA4', intgrou = 'condition')
plotCounts(dds_beta, gene = 'GFPT2', intgrou = 'condition')
# Heatmap
top_100 <- as.data.frame(x) %>% rownames_to_column() %>% arrange(padj) %>% head(100)
counts <- assay(dds_beta)[rownames(dds_beta) %in% top_100$rowname, ]
counts <- t(scale(t(counts), center = T, scale =T))
Heatmap(counts)
# Heatmap
top_50 <- as.data.frame(x) %>% rownames_to_column() %>% arrange(padj) %>% head(50)
counts <- assay(dds_beta)[rownames(dds_beta) %in% top_50$rowname, ]
counts <- t(scale(t(counts), center = T, scale =T))
Heatmap(counts)
# An alternative with this sort of design is to use the liklihood ratio test
# Using the LRT version of this to identify any genes with changes
dds_lrt <- DESeq(dds, test = 'LRT', full = ~condition, reduced = ~1)
# p-values here mean is there a difference between a model that contains our 'condition' and one without that
# But we can extract specific logFoldChanges as before
# but p-values will always be the same ( difference between full model and reduced)
resultsNames(dds_lrt)
res_lrt_brg <- lfcShrink(dds_lrt, contrast = c('condition', 'Brg1', 'NS'), type = 'ashr' )
res_lrt_brm <- lfcShrink(dds_lrt, contrast = c('condition', 'Brm', 'NS'), type = 'ashr' )
# fold changes differ
plot(res_lrt_brg$log2FoldChange, res_lrt_brm$log2FoldChange)
# but pvalues are the same
table(res_lrt_brg$padj == res_lrt_brm$padj)
load('data/arid2_es.Rda')
dds
metadata(dds0
metadata(dds)
metadata(dds)
metadata(dds)$version
dds
es_dds <- dds
es_dds <- DESeq(es_dds)
design(es_dds)
# controlling for treatment, does genotype have an effect
res_genotype <- lfcShrink(dds, contrast = c('genotype', 'ARID2', 'WT'), type = 'ashr' )
es_dds <- DESeq(es_dds)
View(res_double)
# controlling for treatment, does genotype have an effect
res_genotype <- lfcShrink(es_dds, contrast = c('genotype', 'ARID2', 'WT'), type = 'ashr' )
summary(res_genotype)
res_genotype %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(padj) %>%
head(20)
df <- plotCounts(dds, gene = 'Mapk8ip2', intgroup = c('genotype', 'treat' ), returnData = T)
df %>%
ggplot(aes(x = treat, y = log2(count), color = genotype) ) +
geom_point(position = position_dodge(0.5))
design(es_dds)
# Since we have multiple genotype and treatments, and LRT test might be better
dds_treat <- DESeq(dds, test = 'LRT', full = ~ genotype + treat, reduced = ~genotype)
resultsNames(dds_treat)
res_treat <- lfcShrink(dds_treat, contrast= c('treat', 'EB', 'ES'), type = 'ashr' )
res_treat
res_genotype2 <- lfcShrink(dds_treat, contrast = c('genotype' , 'ARID2', 'WT'), type = 'ashr')
res_genotype2
summary(res_treat)
table(res_treat$padj == res_genotype2$padj)
res_treat %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(padj) %>%
head(20)
df <- plotCounts(dds, gene = 'Olfr1459', intgroup = c('genotype', 'treat' ), returnData = T)
df %>%
ggplot(aes(x = treat, y = log2(count), color = genotype) ) + geom_point(position = position_dodge(0.5))
# Is there an effect that differs by genotype
dds_interaction <- dds
design(dds_interaction) <- formula(~treat + genotype + treat:genotype)
dds_interaction <- DESeq(dds_interaction, test = 'LRT',
full = design(dds_interaction),
reduced = ~genotype + treat)
resultsNames(dds_interaction) # while it looks like you could extract other comparisons,
# all the p-values come from the LRT models we tested, so they will differ than if we perform the Wald tests above
res_interaction <- lfcShrink(dds_interaction, name = 'treatFGF48.genotypeWT', type = 'ashr' )
# all the p-values come from the LRT models we tested, so they will differ than if we perform the Wald tests above
res_interaction <- lfcShrink(dds_interaction, contrast = 'treatFGF48.genotypeWT', type = 'ashr' )
# all the p-values come from the LRT models we tested, so they will differ than if we perform the Wald tests above
res_interaction <- lfcShrink(dds_interaction, coef = 'treatFGF48.genotypeWT', type = 'ashr' )
summary(res_interaction)
res_interaction %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(padj) %>%head(20)
res_interaction
res_interaction %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(padj) %>%head(20)
plotCounts(dds_interaction, gene = 'Srp54b', intgroup = c('genotype', 'treat' ), returnData=T) %>%
ggplot(aes(x = genotype, y = count, color = treat ))  + geom_point() +
facet_wrap(~treat)
res_genotype_WT_vs_ARID2 <- results(dds_interaction, contrast = c('genotype', 'WT', 'ARID2'))
table(res_genotype_WT_vs_ARID2$padj < 0.1)
table(res_interaction$padj < 0.1)
table(res_genotype_WT_vs_ARID2$log2FoldChange > 5)
table(res_interaction$log2FoldChange > 5)
res_genotype_WT_vs_ARID2 %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(log2FoldChange) %>% head(20)
