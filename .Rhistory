width = 0.1)
iris
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width)) +
geom_col(fill = 'grey90', color = 'grey20') +
geom_errorbar(aes(ymin = mean_sepal_width-sd_sepal_width,
ymax = mean_sepal_width+sd_sepal_width),
width = 0.1)  +
geom_point(aes(x = Species, y = Sepal.Width, color = Species), data = iris)
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width)) +
geom_col(fill = 'grey90', color = 'grey20') +
geom_errorbar(aes(ymin = mean_sepal_width-sd_sepal_width,
ymax = mean_sepal_width+sd_sepal_width),
width = 0.1)  +
geom_jitter(aes(x = Species, y = Sepal.Width, color = Species), data = iris, width =0.1)
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width)) +
geom_col(fill = 'grey90', color = 'grey20') +
geom_jitter(aes(x = Species, y = Sepal.Width, color = Species), data = iris, width =0.1)  +
geom_errorbar(aes(ymin = mean_sepal_width-sd_sepal_width,
ymax = mean_sepal_width+sd_sepal_width),
width = 0.1)
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width)) +
geom_col(fill = 'grey90', color = 'grey20') +
geom_jitter(aes(x = Species, y = Sepal.Width, color = Species), data = iris, width =0.1,
alpha = 0. 1)  +
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width)) +
geom_col(fill = 'grey90', color = 'grey20') +
geom_jitter(aes(x = Species, y = Sepal.Width, color = Species), data = iris, width =0.1,
alpha = 0.1)  +
geom_errorbar(aes(ymin = mean_sepal_width-sd_sepal_width,
ymax = mean_sepal_width+sd_sepal_width),
width = 0.1)
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width)) +
geom_col(fill = 'grey90', color = 'grey20') +
geom_jitter(aes(x = Species, y = Sepal.Width, color = Species), data = iris, width =0.1,
alpha = 0.1)  +
geom_errorbar(aes(ymin = mean_sepal_width-sd_sepal_width,
ymax = mean_sepal_width+sd_sepal_width),
width = 0.5)
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width)) +
geom_col(fill = 'grey90', color = 'grey20') +
geom_jitter(aes(x = Species, y = Sepal.Width, color = Species), data = iris, width =0.1,
alpha = 0.5)  +
geom_errorbar(aes(ymin = mean_sepal_width-sd_sepal_width,
ymax = mean_sepal_width+sd_sepal_width),
width = 0.1)
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width)) +
geom_col(fill = 'grey90', color = 'grey20') +
geom_jitter(aes(x = Species, y = Sepal.Width, color = Species), data = iris, width =0.1,
alpha = 0.4)  +
geom_errorbar(aes(ymin = mean_sepal_width-sd_sepal_width,
ymax = mean_sepal_width+sd_sepal_width),
width = 0.1)
?aes
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width, fill = Species)) +
geom_col() +
theme_bw()
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width, fill = Species)) +
geom_col(color = 'grey20') +
theme_bw()
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width, fill = Species)) +
geom_col(color = 'grey20') +
theme_bw() +
theme(panel.grid = element_blank(),
axis.text.x = element_text(size = 24, family = 'serif'))
# Make the bars the color you want
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width, fill = Species)) +
geom_col(color = 'grey20') +
theme_bw() +
theme(panel.grid = element_blank(),
axis.text.x = element_text(size = 24, family = 'serif')) +
scale_fill_manual(values = c('steelblue', 'forestgreen', 'goldenrod'))
# Make the bars the color you want
iris_summary |>
ggplot(aes(x = Species, y = mean_sepal_width, fill = Species)) +
geom_col(color = 'grey20') +
theme_bw() +
scale_fill_manual(values = c('steelblue', 'forestgreen', 'goldenrod'))
factor(iris_summary$Species)
# As always, start by loading needed libraries
library(tidyverse)
library(DESeq2) # main package for differential expression
library(tximport) # Helper functions for reading in count data
#install.packages('devtools')
#devtools::install_github('stephenturner/annotables')
library(annotables)
# Import design data
design <- read_csv('/Users/jraab/GitHub/GNET749_RNAseq/data/class_data_info.csv')
design
# Import design data
design <- read_csv('data/class_data_info.csv')
design
# This line creates a new column to keep track of where each Salmon output file is
# file.path makes sticks the arguments together with / between them to make path names
design$path <- file.path('data/salmon', paste0(design$Sample, '_decoy_quant'), 'quant.sf')
design
grch38_tx2gene |> head()
# Import Salmon quant files
txi <- tximport(design$path, type = 'salmon', tx2gene = annotables::grch38_tx2gene, ignoreTxVersion = T)
txi$counts %>% head()
colnames(txi$counts) <- design$Sample
colnames(txi$counts)
head(txi$counts)
txi
# The next line creates a summarizedExperiment object that can be usd for
#     differential testing
dds <- DESeqDataSetFromTximport(txi , colData = design, design = ~ Group )
dds
metadata(dds) # DESEq version
#################################################################################
# This is how we run the actual differential test with defaults
# is very easy if you have a simple experimental design and analysis approach
###############################################################################
des <- DESeq(dds) # This runs all the DESeq steps
assays(dds)$avgTxLength
assays(dds)$avgTxLength |> as_tibble()
assays(dds)$avgTxLength |> rownames_to_column () |> as_tibble()
assays(dds)$avgTxLength |> rownames_to_column() |> as_tibble()
assays(dds)$avgTxLength |>head()
res <- results(des) # this returns a DESeq results object
res
summary(res)
# Enrichment analysis in R
library(tidyverse)
library(msigdbr)  # install.packages('msigdbr')
# Below packages can be installed with BiocManager::install(c('singscore', 'clusterProfiler', 'DOSE', 'org.Hs.eg.db') )
library(singscore)
# Packages for Class 4
BiocManager::install(c('DOSE', 'clusterProfiler', 'GSVA', 'singscore', 'enrichplot', 'biomaRt', 'msigdbr', 'limma', 'sva', 'GSVAdata', 'org.Hs.eg.db'))
# Enrichment analysis in R
library(tidyverse)
library(msigdbr)  # install.packages('msigdbr')
# Below packages can be installed with BiocManager::install(c('singscore', 'clusterProfiler', 'DOSE', 'org.Hs.eg.db') )
# I tried to put these in a script to install - see enrichment_packages.R
library(singscore)
library(clusterProfiler)
library(enrichplot)
library(biomaRt)
library(GSVA)
library(GSVAdata)
library(UpSetR)
library(fgsea)
install.packages(c('UpSetR', 'vennDiagram', 'ggnewscale'))
install.packages(c('UpSetR', 'VennDiagram', 'ggnewscale'))
# Packages for Class 4
BiocManager::install(c('DOSE', 'clusterProfiler', 'GSVA', 'singscore', 'enrichplot', 'biomaRt', 'msigdbr', 'limma', 'sva', 'GSVAdata', 'org.Hs.eg.db', 'fgsea'))
library(UpSetR)
library(ggvenn)
library(ggVennDiagram)
library(fgsea)
devtools::install_github("yanlinlin82/ggvenn")
devtools::install_github('gaospecial/ggVennDiagram')
# There may be an issue with RSqlite affecting loading of some packages
# If you get an issue with RSqlite - try the following
#remotes::install_version("RSQLite", version = "2.2.5")
# Either install the older version of rsqlite using above code or run
#options(connectionObserver=NULL) # prior to running the next line
# THe above no longer seems required,  but I'm leaving it there in case anyone has issues install/loading these libraires
library(org.Hs.eg.db)
################################################################################
# Establish some of the data in the formats we'll need today
# Load the log2 fold change data set for the BRG1 knockdown experiment
brg_res <- read_csv('/Users/jraab/GitHub/GNET749_RNAseq/data/results_brg1.csv')
brg1_res
brg_res
annotables::grch38
# an alternative is to use the bitr function from clusterprofiler. Included here for completeness
gene.df <- bitr(brg_res$rowname, fromType = "SYMBOL",
toType = c("ENSEMBL", "SYMBOL", 'ENTREZID'),
OrgDb = org.Hs.eg.db)
# Add the entrez Ids
brg_res <- brg_res %>% left_join(mart_res, by = c('rowname' = 'external_gene_name'))
head(brg_res)
head(brg_res)
# Identify significant up and downregulated genes  - These are useful for overrepresentation analysis
brg1_up <- brg_res %>% filter(padj < 0.05, log2FoldChange > 1.5 ) # significant upregulated
brg1_down <- brg_res %>% filter(padj < 0.05, log2FoldChange < -1.5) # significant downregulated
brg1_up
brg_down
brg1_down
# Create a rank ordered list of genes - These ranked lists are useful for Gene Set Enrichment analyssi
brg1_res_ordered <- brg_res %>% arrange(desc(log2FoldChange))
brg1_ol <- brg1_res_ordered$log2FoldChange
brg1_ids <- brg1_res_ordered$log2FoldChange
names(brg1_ol) <- brg1_res_ordered$rowname
names(brg1_ids) <- brg1_res_ordered$entrezgene_id
brg1_ol
brg1_ids
brg1_res_ordered
gene.df
# Add the entrez Ids
brg_res <- brg_res %>% left_join(gene.df, by = c('rowname' = 'SYMBOL'))
head(brg_res)
# Identify significant up and downregulated genes  - These are useful for overrepresentation analysis
brg1_up <- brg_res %>% filter(padj < 0.05, log2FoldChange > 1.5 ) # significant upregulated
brg1_down <- brg_res %>% filter(padj < 0.05, log2FoldChange < -1.5) # significant downregulated
# Create a rank ordered list of genes - These ranked lists are useful for Gene Set Enrichment analyssi
brg1_res_ordered <- brg_res %>% arrange(desc(log2FoldChange))
brg1_ol <- brg1_res_ordered$log2FoldChange
brg1_ids <- brg1_res_ordered$log2FoldChange
names(brg1_ol) <- brg1_res_ordered$rowname
names(brg1_ids) <- brg1_res_ordered$entrezgene_id
# A few methods, (GSVA and SingScore) need full data (count/gene ranks)
load('data/GSE102560_dds.Rda')# load dds
dds <- DESeq(dds) # running this here so we get proper size factors etc
dds_fix <- dds
assay(dds_fix) <- limma::removeBatchEffect(assay(dds_fix), dds$rep)
counts <- counts(dds_fix, norm = T)
counts <- counts[rowMeans(counts) > 10, ]
dim(counts)
# Over representation analysis using KEGG
kegg_up <-clusterProfiler::enrichKEGG(gene         = brg1_up$entrezgene_id,
organism     = 'hsa',
pvalueCutoff = 0.05)
# Over representation of GO terms
brg_up_go <- enrichGO(gene    = brg1_up$ENTREZID,
universe      = brg_res$ENTREZID,
OrgDb         = org.Hs.eg.db,
ont           = c("MF"),
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
# Over representation analysis using KEGG
kegg_up <-clusterProfiler::enrichKEGG(gene = brg1_up$ENTREZID,
organism     = 'hsa',
pvalueCutoff = 0.05)
kegg_down <- clusterProfiler::enrichKEGG(gene   = brg1_down$ENTREZID,
organism = 'hsa',
pvalueCutoff = 0.05)
dotplot(kegg_up)
barplot(kegg_up)
dotplot(kegg_down)
barplot(kegg_down)
kegg_up
class(kegg_up)
?enrichResult
??enrichResult
as.data.frame() |> kegg_up
kegg_up |> as.data.frame()
kegg_up |> as.data.frame() |>
ggplot(aes(x = -log10(qvalue), y = Description, size = Count)) +
geom_point()
# Over representation of GO terms
brg_up_go <- clusterProfiler::enrichGO(gene    = brg1_up$ENTREZID,
universe      = brg_res$ENTREZID,
OrgDb         = org.Hs.eg.db,
ont           = c("MF"),
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
dotplot(brg_up_go)
emapplot(pairwise_termsim(brg_up_go))
emapplot(pairwise_termsim(kegg_down))
?pairwise_termsim
# Can remove similar terms - does not work if using ont = 'ALL'
dotplot(simplify(x = brg_up_go))
# Can remove similar terms - does not work if using ont = 'ALL'
dotplot(simplify(x = brg_down_go))
# Can remove similar terms - does not work if using ont = 'ALL'
dotplot(simplify(x = kegg_down))
brg_down_go <- clusterProfiler::enrichGO(gene    = brg1_down$ENTREZID,
universe      = brg_res$ENTREZID,
OrgDb         = org.Hs.eg.db,
ont           = c("MF"),
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
dotplot(brg_down_go)
# termsim can be useful for seeing how similar categories are
emapplot(pairwise_termsim(brg_down_go))
# Can remove similar terms - does not work if using ont = 'ALL'
dotplot(simplify(x = brg_down_go))
# Can remove similar terms - does not work if using ont = 'ALL'
dotplot(brg_down_go)
dotplot(simplify(x = brg_down_go))
heatplot(brg_down_go, foldChange = brg1_ol)  #not terribly interesting since we limited to up or downregulated genes
heatplot(c(brg_up_go, brg_down_go), foldChange = brg1_ol)  #not terribly interesting since we limited to up or downregulated genes
brg_all_go <- enrichGO(gene = c(brg1_up$ENTREZID, brg1_down$ENTREZID),
universe      = brg_res$entrezgene_id,
OrgDb         = org.Hs.eg.db,
ont           = 'MF',
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE))
brg_all_go <- enrichGO(gene = c(brg1_up$ENTREZID, brg1_down$ENTREZID),
universe      = brg_res$entrezgene_id,
OrgDb         = org.Hs.eg.db,
ont           = 'MF',
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
brg_down)g
brg_down_go
brg_all_go <- enrichGO(gene = c(brg1_up$ENTREZID, brg1_down$ENTREZID),
universe      = brg_res$ENTREZID,
OrgDb         = org.Hs.eg.db,
ont           = 'MF',
pAdjustMethod = "BH",
pvalueCutoff  = 0.01,
qvalueCutoff  = 0.05,
readable      = TRUE)
brg_all_go
heatplot(brg_all_go, foldChange = brg1_ol)
#  You can also do overrepresentation with any arbitrary gene set
# Here we'll get the msigdb data from the msigdbr package
msigdbr_df <- msigdbr() # this retrieves all the data sets
length(unique(msigdbr_df$gs_name) ) # ~32,000 gene sets
msigdr_df |> head()
msigdbr_df |> head()
msigdbr_t2g %>% head()
msigdbr_t2g = msigdbr_df %>% dplyr::select(gs_name, human_gene_symbol) %>% as.data.frame() # Make a df that contains the terms and genes
msigdbr_t2g %>% head()
# Generic enricher functions - run on the whole data set - not for class, too slow
brg1_up_enr <- clusterProfiler::enricher(gene = brg1_up$rowname, TERM2GENE = msigdbr_t2g)
brg1_down_enr <- clusterProfiler::enricher(gene = brg1_down$rowname, TERM2GENE = msigdbr_t2g)
dotplot(brg1_up_enr)
barplot(brg1_down_enr)
cnetplot(brg1_up_enr)
emapplot(pairwise_termsim(brg1_up_enr) )
emapplot(pairwise_termsim(brg1_down_enr))
# I often like the hallmark data set, but I'm also filtering here so this runs a little faster, you could run this on the whole data frame
# Let's run the above but just on the hallmark genes
hallmark <- msigdbr_df %>% filter(gs_cat == 'H')
hallmark_t2g <- hallmark %>% dplyr::select(gs_name, human_gene_symbol) %>% as.data.frame()
colnames(hallmark_t2g) <- c('TERM', 'GENE')
e_hall <- enricher(gene = c(brg1_down$rowname, brg1_up$rowname), TERM2GENE = hallmark_t2g )
dotplot(e_hall)
dotplot(e_hall)
emapplot(pairwise_termsim(e_hall) )
?fgsea
fgsea(pathways= as.list(hallmark_t2g), stats = rev(sort(brg1_ol)) )
rev(sort(brg1_ol))
as.list(hallmark_t2g)
hallmark_t2g
hallmark_t2g |> pivot_wider(names_from = TERM, values_from = GENE)
hallmark_t2g |> pivot_wider(names_from = TERM, values_from = GENE) |> as_list()
hallmark_t2g |> pivot_wider(names_from = TERM, values_from = GENE) |> as.list()
hallmark_t2g_list <- hallmark_t2g |> pivot_wider(names_from = TERM, values_from = GENE) |> as.list() |> unlist()
hallmark_t2g_list
hallmark_t2g_list <- hallmark_t2g |> pivot_wider(names_from = TERM, values_from = GENE) |> as.list()
hallmark_t2g_list <- hallmark_t2g |> pivot_wider(names_from = TERM, values_from = GENE) |> as.list()
hallmark_t2g_list
fgsea(pathways= hallmark_t2g_list, stats = rev(sort(unique(brg1_ol))) )
rev(sort(unique(brg1_ol)))
fgsea(pathways= hallmark_t2g_list, stats = rev(sort(brg1_ol))) )
fgsea(pathways= hallmark_t2g_list, stats = rev(sort(brg1_ol)))
brg1_hallmark %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(NES) %>%
mutate(rowname = factor(rowname, levels = rowname) ) %>%
ggplot(aes(x = rowname, y = NES, fill = as.factor(sign(NES)))) +
geom_col(color = 'grey30') +
coord_flip() +
scale_fill_manual(values = c('blue', 'gold2') )
#### Gene Set Enrichment Analysis - main benefit is that it does not require an arbitrary threshold ######
brg1_hallmark <- GSEA(geneList = rev(sort(brg1_ol)), TERM2GENE = hallmark_t2g, by = 'fgsea')
brg1_hallmark %>% as.data.frame() %>% head()
brg1_hallmark %>%
as.data.frame() %>%
rownames_to_column() %>%
arrange(NES) %>%
mutate(rowname = factor(rowname, levels = rowname) ) %>%
ggplot(aes(x = rowname, y = NES, fill = as.factor(sign(NES)))) +
geom_col(color = 'grey30') +
coord_flip() +
scale_fill_manual(values = c('blue', 'gold2') )
gseaplot2(brg1_hallmark, geneSetID = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB')
gseaplot(brg1_hallmark, geneSetID = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB')
# We can extract a specific set of these genes
hallmark_subset <- hallmark_t2g %>% filter(TERM == 'HALLMARK_TNFA_SIGNALING_VIA_NFKB') %>% pull(GENE)
# and plot this subset as a volcano plot
brg_res %>%
filter(rowname %in% hallmark_subset) %>%
ggplot(aes(x =log2FoldChange, y = -log10(padj), color = padj < 0.05 )) +
geom_point() +
scale_color_manual(values = c('grey30', 'red2')) +
theme_bw()
# and plot this subset as a volcano plot
brg_res %>%
filter(rowname %in% hallmark_subset) %>%
ggplot(aes(x =log2FoldChange, y = -log10(padj), color = padj < 0.05 )) +
geom_point() +
scale_color_manual(values = c('grey30', 'red2')) +
theme_bw()  +
ggrepel::geom_label_repel(aes(label = rowname))
# and plot this subset as a volcano plot
brg_res %>%
filter(rowname %in% hallmark_subset) %>%
ggplot(aes(x =log2FoldChange, y = -log10(padj), color = padj < 0.05 )) +
geom_point() +
scale_color_manual(values = c('grey30', 'red2')) +
theme_bw()  +
ggrepel::geom_label_repel(aes(label = rowname), color = 'steelblue')
# and plot this subset as a volcano plot
brg_res %>%
filter(rowname %in% hallmark_subset) %>%
ggplot(aes(x =log2FoldChange, y = -log10(padj), color = padj < 0.05 )) +
geom_point() +
scale_color_manual(values = c('grey70', 'red2')) +
theme_bw()  +
ggrepel::geom_label_repel(aes(label = rowname), color = 'steelblue')
# We want our original data, which we can load from a saved DESeqDataSet
# Remember counts is coming from the entire dds object we loaded up top
rg <- rankGenes(counts) # this ranks the expression level in each of our samples
rg
# Now we pass this to simplescore along with a list of genes for our data set
ss <- simpleScore(rg, upSet = unique(hallmark_subset) )
upSet
unique(hallmark_subset)
rg
rownames(rg)
rownames(rg) == 'CD44'
rownames(rg) == 'CSPG8'
rownames(rg) == 'CSPG8' |> table()
table(rownames(rg) == 'CSPG8')
table(rownames(rg) == 'HCELL')
table(rownames(rg) == 'MC56')
table(rownames(rg) == 'MIC4')
table(rownames(rg) == 'MDU2')
table(rownames(rg) == 'MDU3')
ss
# Now we pass this to simplescore along with a list of genes for our data set
ss <- simpleScore(rg, upSet = unique(hallmark_subset) )
table(rownames(rg) == 'CMKOR1')
table(rownames(rg) == 'CXCR7')
table(rownames(rg) == 'RDU1')
table(rownames(rg) == 'RDC1')
table(rownames(rg) == 'GPR159')
table(rownames(rg) == 'SCYA2')
table(rownames(rg) == 'MCP1')
brg1_down
brg1_res
brg_res
brg_res |> filter(rowname == 'IL6')
counts
counts[rownames(counts) == 'IL6']
counts[rownames(counts) == 'IL6',]
counts <- counts(dds_fix, norm = T)
#counts <- counts[rowMeans(counts) > 10, ]
dim(counts)
ridgeplot(brg1_hallmark, fill = 'p.adjust', core_enrichment = T)
# THe core_enrichment argument tells the plot to only include those genes that were in the core_enrichment column
# these are the genes that contribue the most to the scores
ridgeplot(brg1_hallmark, fill = 'p.adjust', core_enrichment = F)
# We can extract a specific set of these genes
hallmark_subset <- hallmark_t2g %>% filter(TERM == 'HALLMARK_TNFA_SIGNALING_VIA_NFKB') %>% pull(GENE)
# and plot this subset as a volcano plot
brg_res %>%
filter(rowname %in% hallmark_subset) %>%
ggplot(aes(x =log2FoldChange, y = -log10(padj), color = padj < 0.05 )) +
geom_point() +
scale_color_manual(values = c('grey70', 'red2')) +
theme_bw()  +
ggrepel::geom_label_repel(aes(label = rowname), color = 'steelblue')
# We want our original data, which we can load from a saved DESeqDataSet
# Remember counts is coming from the entire dds object we loaded up top
rg <- rankGenes(counts) # this ranks the expression level in each of our samples
rg
# Now we pass this to simplescore along with a list of genes for our data set
ss <- simpleScore(rg, upSet = unique(hallmark_subset) )
table(rownames(rg) == 'IGFBP10')
table(rownames(rg) == 'CYR61')
# Using this we can compare our scores across our samples
# best to incorporate our conditions
ss %>% as.data.frame() %>%
rownames_to_column() %>%
separate(rowname, into = c('group', 'rep'), sep = '_', remove =F )  %>%
ggplot(aes(x = group, y = TotalScore)) + geom_point()
grepl('HSIAO_LIVER_SPECIFIC_GENES', msigdbr_df$gs_name)
#You can also give simplescore an upregulated and downregulated set
# It's possible the hallmark set contains both, which blunts the score somewhat
# HSIAO_LIVER_SPECIFIC_GENES
liver_genes <- msigdbr_df |> filter(gs_name == 'HSIAO_LIVER_SPECIFIC_GENES') |> dplyr::select(gs_name, gene_symbol)
liver_genes
ss_liver <- simpleScore(rg, upSet= unique(hallmark_subset), downSet = unique(liver_genes$gene_symbol) )
hallmark_subset
ss_liver %>% as.data.frame() %>%
rownames_to_column() %>%
separate(rowname, into = c('group', 'rep'), sep = '_', remove =F )  %>%
ggplot(aes(x = group, y = TotalScore)) + geom_point()
################################################################################
# Overlaps between groups  ####################################################
################################################################################
brg_res <- read_csv('/Users/jraab/GitHub/GNET749_RNAseq/data/results_brg1.csv')
brm_res <- read_csv('/Users/jraab/GitHub/GNET749_RNAseq//data/results_brm.csv')
double_res <- read_csv('/Users/jraab/GitHub/GNET749_RNAseq/data/results_double.csv')
brg_sig <- brg_res %>% filter(padj < 0.05)
brm_sig <- brm_res %>% filter(padj <0.05)
double_sig <- double_res %>% filter(padj < 0.05)
x <- list(brg=brg_sig$rowname, brm=brm_sig$rowname, double=double_sig$rowname)  # list of our gene names, 1 element for each data set
head(x)
# If you want separate colors for each, this works well
ggvenn(x)
ggvenn(x[1:2])
ggvenn(x, fill_color = c('red', 'blue', 'green') )
